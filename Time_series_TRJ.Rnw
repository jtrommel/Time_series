\documentclass{tufte-book}
\usepackage{graphicx}  % werken met figuren
\usepackage{gensymb} % werken met wetenschappelijke eenheden\usepackage{geometry}
\usepackage{changepage} % http://ctan.org/pkg/changepage
\usepackage[dutch,british]{babel} % instelling van de taal (woordsplitsing, spellingscontrole)
\usepackage[parfill]{parskip} % Paragrafen gescheiden door witte lijn en geen inspringing
\usepackage[font=small,skip=3pt]{caption} % Minder ruimte tussen figuur/table en ondertitel. Ondertitel klein
\usepackage{capt-of}
\usepackage{indentfirst}
\setlength{\parindent}{0.7cm}
\usepackage{enumitem} % Laat enumerate werken met letters
\usepackage{url}
\usepackage{lipsum}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
% Prints a trailing space in a smart way.
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{amsmath}

\DeclareGraphicsExtensions{.pdf,.png,.jpg}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
%   General parameters, for ALL pages:
    \renewcommand{\topfraction}{0.9}	% max fraction of floats at top
    \renewcommand{\bottomfraction}{0.9}	% max fraction of floats at bottom
%   Parameters for TEXT pages (not float pages):
    \setcounter{topnumber}{2}
    \setcounter{bottomnumber}{2}
    \setcounter{totalnumber}{4}     % 2 may work better
    \renewcommand{\textfraction}{0.1}	% allow minimal text w. figs
%   Parameters for FLOAT pages (not text pages):
    \renewcommand{\floatpagefraction}{0.8}	% require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\setcounter{secnumdepth}{3}

\newcommand{\tthdump}[1]{#1}

\newcommand{\openepigraph}[2]{
  \begin{fullwidth}
  \sffamily\large
    \begin{doublespace}
      \noindent\allcaps{#1}\\ % epigraph
      \noindent\allcaps{#2} % author
    \end{doublespace}
  \end{fullwidth}
}


\usepackage{makeidx}
\makeindex

\title{Time series}
\author{Jan Trommelmans}

\begin{document}
\SweaveOpts{concordance=TRUE,prefix.string=TS}
\setkeys{Gin}{width=1.1\marginparwidth} %% Sweave

\frontmatter

\newpage\thispagestyle{empty}
\openepigraph{
It's tough to make predictions, especially about the future.
}{Yogi Berra
}

\maketitle

\chapter*{Introduction}
\label{ch:introduction}

In the ''Good Judgement Open" forecast tournament, many questions deal with time series: data obtained at regularly spaced time intervals. Examples are: daily closing price of Brent Crude Oil, polling results for different political parties prior to an election, the exchange rate of one currency vs. another. These time series can exhibit a number of properties:
\begin{enumerate}
  \item a \emph{trend}. This can take the form of a function (linear, polynomial, exponential ...) that we obtain from a model. Or it can be found in the form of calculated values using a smoothing operation.
  \item a \emph{periodic} element. Again this can be modelled by a function (e.g. the sum of sine-funtion using the Discrete Fourier Transform of the (detrended) signal). Or it can take the form of calculated values such as Additive/Multiplicative Seasonal Effects.
  \item an element of \emph{error}. This can be caused by unknown factors, unforeseen periodic influences, measuring and/or rounding errors etc.
\end{enumerate}

The programming language \textsf{R} has a specific object to work with time series. It is aptly named \emph{time series object}. This object does not only include the data that were recorded, but also information about the time it was recorded. \textsf{R} base has the \texttt{ts}-command which turns a vector or matrix of data into a time series object. When we want to transform our data into a time series object with \texttt{ts}, we have to include a parameter which is called \texttt{frequency}. This causes a lot of problems (for me a least).

The aim of this article is to get some clarity about how to set this parameter \texttt{frequency} and its consequences when using \textsf{R} base languange or one of the many packages that were specifically developed for working with time series objects.

\mainmatter

\chapter{Working with time series in a standard data frame}
\label{ch:data frame}

\section{Making your own date column}
\label{sec:own date column}

\newthought{Time series data} are usually available as a vector or a matrix of numerical values. An example

<<echo=FALSE>>=
library(tidyverse)
library(xtable)
library(lubridate)
library(gridExtra)
@

% Setting the ggplot theme:
<<echo=FALSE>>=
JT.theme <- theme(panel.border = element_rect(fill = NA, colour = "gray10"),
                  panel.background = element_blank(),
                  panel.grid.major = element_line(colour = "gray85"),
                  panel.grid.minor = element_line(colour = "gray85"),
                  panel.grid.major.x = element_line(colour = "gray85"),
                  axis.text = element_text(size = 8 , face = "bold"),
                  axis.title = element_text(size = 9 , face = "bold"),
                  plot.title = element_text(size = 12 , face = "bold"),
                  strip.text = element_text(size = 8 , face = "bold"),
                  strip.background = element_rect(colour = "black"),
                  legend.text = element_text(size = 8),
                  legend.title = element_text(size = 9 , face = "bold"),
                  legend.background = element_rect(fill = "white"),
                  legend.key = element_rect(fill = "white"))
@

% Defining my functions
<<echo=FALSE>>=
JTR.FFT <- function(signal.df) {
  # This function calculates the FFT for a time series stored in a data frame with as first column the time (or order of measurement) and as second column the vector of measurements.
  # The result is a list. 
  # The first element of the list is freqspec: the N frequencies plus for each frequency the amplitude and phase.
  # The second element of the list is resultaat: a data frame with those frequencies for which the amplitude  are at least 33% of the maximum amplitude. The data frame is sorted from highes amplitude to lowest. This data fram can be seen as containing the most influencial frequencies.
  signal <- signal.df
  names(signal) <- c("t","x")
  N <- nrow(signal)
  Ts <- as.numeric(signal$t[2]-signal$t[1])
  Fs <- 1/Ts
  # Calculation of the double sided en single sided spectrum
  z <- fft(signal$x)
  P2 <- Mod(z/N)
  P1 <- P2[1:((N/2)+1)]
  P1[2:(length(P1)-1)] <- 2*P1[2:(length(P1)-1)]
  freq <- seq(0, (Fs/2)-(Fs/N), Fs/N)
  freqspec <- data.frame(freq=freq,amp=P1[1:(N/2)],arg=Arg(z[1:(N/2)]))
  # Finding the most important elements in the frequency spectrum
  grens <- ifelse(freqspec$freq[freqspec$amp==max(freqspec$amp)]==0,max(freqspec$amp[2:nrow(freqspec)])/3,max(freqspec$amp)/3)
  aantal <- length(freqspec$amp[freqspec$amp>grens])
  resultaat <- data.frame(freq=rep(0,aantal), amp=rep(0,aantal), fasehoek=rep(0,aantal))
  resultaat <- data.frame(freq=freqspec$freq[freqspec$amp>grens],
                          amp=freqspec$amp[freqspec$amp>grens],
                          fasehoek_pi=freqspec$arg[freqspec$amp>grens]/pi)
  resultaat <- resultaat[order(-resultaat$amp),]
  return(list("freqspec"=freqspec,"resultaat"=resultaat))
}
@

<<echo=FALSE>>=
JT.example1 <- c(6, 5.5, 4.2, 2.8, 3.7, 7.1, 6.8, 4.4, 6.7, 7.9)
JT.example1.df <- data.frame(value=JT.example1) 
print(JT.example1.df)
@

When these data are collected sequentially, the rownames give the order. We put this order into a new variable ''nr".

<<label=JTex1,fig=TRUE,include=FALSE, echo=FALSE>>=
JT.example1.df <- data.frame(nr=c(1:length(JT.example1)), value=JT.example1)
ggplot(data=JT.example1.df) +
  geom_point(aes(x=nr,y=value), size=3, color="red") +
  geom_linerange(aes(x=nr,ymin=0,ymax=value),linetype=3, size=1) +
  scale_x_continuous(breaks=c(1:length(JT.example1))) +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Example of equally spaced observations") +
  JT.theme
@

\begin{marginfigure}[-7cm]
\includegraphics[width=1\textwidth]{TS-JTex1}
\caption{}
\label{fig:JTex1}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newthought{Of course} it could be interesting to have the actual time (date + hms) at which the observations were made. The \texttt{lubridate}-package gives us simple to use and easy to understand function that we can use to create \texttt{date}-objects in R. For example: if the measurements were made on October 8th 2015, starting at 13:45 and done every minute we can create a column ''date" using \texttt{lubridate} and \texttt{seq}-function. Take care to set the ''by"-parameter with as.difftime().

<<>>=
Sys.setenv(TZ="Europe/Brussels")
JT.example1.df$date <- seq(ymd_hms("2015-10-08 13:45:00"), 
                           length = 10, by=as.difftime(minutes(1)))
str(JT.example1.df)
@

We can see that the ''date"-variable has the class \texttt{date}.

<<echo=FALSE>>=
print(JT.example1.df)
@

ggplot can handle date-type variables. This has the advantage that the time-axis is now using the correct times at which the measurements were made.

<<label=JTex2,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=JT.example1.df) +
  geom_point(aes(x=date, y=value), size=3, color="red") +
  geom_linerange(aes(x=date, ymin=0,ymax=value),linetype=3, size=1) +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Example of equally spaced observations with exact times") +
  JT.theme
@

\begin{marginfigure}[-7cm]
\includegraphics[width=1\textwidth]{TS-JTex2}
\caption{}
\label{fig:JTex2}
\setfloatalignment{b}
\end{marginfigure}

Other sequences can be generated in the same way:

<<>>=
other.seq <- seq(from=ymd("2017-01-01"), 
                 to=ymd("2017-01-31"), 
                 by=as.difftime(days(2)))
other.seq
@

\newpage
\section{Looking at the data}
\label{sec:visualize}

\newthought{Visualisation} of the data is a good first step because it gives an indication of the basic components of a time series and the way they are linked. This ''linking" is usually described as \emph{additive} or \emph{multiplicative}. I will start with the \emph{additive} linking because I have some problems with the \emph{multiplicative}.

\begin{enumerate}
  \item: the \emph{Level} of the signal: this is the average value of the series.
  \item: the \emph{Trend} of the signal: the change in the series from one period to the other
  \item: the \emph{Periodicity} or \emph{Seasonality} of the signal: short term cyclical behaviour that can be observed several times in the series
  \item: the \emph{Noise} in the signal: random variation caused by measurement error or the influence of unknown factors
\end{enumerate}

\subsection{Additive components of a time series}
\label{subsec:additive}
The \emph{additive} linkage between these components is simple: the complete signal is the sum of all these terms:
\begin{equation}
y[t_{i}] = Level + Trend[t_{i}] + Periodicity[t_{i}] + Noise[t_{i}]
\end{equation}

This seems simple but there is an unusual use of the term \emph{Trend}. For a simple linear dependency of y on t (starting at $t_{start}$ and ending at $t_{end}$), for me the ''trend" is given by:
\begin{equation}
y(t)=b_{0}+b_{1} \left( t-t_{start}  \right)
\end{equation}

However: the \emph{Level} of the time seris is defined as its average and thus as a constant. Assuming that the averages of the periodic part and of the noise are zero, what remains is the average of the linear part $ y(t)=b_{0}+b_{1} \left( t-t_{start}  \right)$:
\begin{equation}
Level=\bar{y}=b_{0} + b_{1} \frac{\left( t_{end}-t_{start} \right)}{2} 
\end{equation}

This means that what is meant by \emph{Trend} is equal to:
\begin{equation}
Trend=y(t)-Level=b_{1}\left[ t-\frac{t_{start}+t_{end}}{2} \right]
\end{equation}

We can generalize this argument for a polynomial function (degree>2) of y. For example: a third degree polynomial for the ''trend":
\begin{equation}
y(t)=b_{0} + b_{1} \left( t-t_{start}  \right) + b_{2} \left( t-t_{start}  \right)^{2} + b_{3} \left( t-t_{start}  \right)^{3}
\end{equation}

The \emph{Level} is its mean value:
\begin{equation}
Level=\bar{y}=\frac{1}{t_{end}-t_{start}} \int\limits_{t_{start}}^{t_{end}} ydt=b_{0}+b_{1}\frac{t_{end}-t_{start}}{2} + b_{2}\frac{(t_{end}-t_{start})^{2}}{3} +  b_{3}\frac{(t_{end}-t_{start})^{3}}{4}
\end{equation}

and the \emph{Trend} is then:
\begin{equation}
Trend=y(t)-Level=b_{1}\left[ (t - t_{start}) - \frac{t_{end} - t_{start}}{2} \right] + b_{2}\left[ (t - t_{start})^{2} - \frac{(t_{end} - t_{start})^2}{3} \right] + b_{3}\left[ (t - t_{start})^{3} - \frac{(t_{end}-t_{start})^3}{4} \right]
\end{equation}

The base signal is white noise: no level, no trend, no periodicity, just noise. Then we can superpose on this a level and/or a trend and/or periodicity. We start with only \texttt{additive} superposition. The possible resulting signals are summarized in Figure~\ref{fig:JTvisual}.

<<label=JTvisual,fig=TRUE,include=FALSE, echo=FALSE>>=
set.seed(123)
t <- c(0:99)
tstart <- min(t)
tend <- max(t)
noise <- rnorm(100,0,0.5)
# coefficients of the trend
b0 <- 1
b1 <- 0.05
b2 <- 0.005
b3 <- -0.00005
level.fixed <- 0
trend.fixed <- 0
level.linear <- b0 + b1*(tend - tstart)/2
trend.linear <- b1*(t - (tstart + tend)/2)
level.poly <- b0 + b1*(tend-tstart)/2 +
  b2*((tend-tstart)^2)/3 +
  b3*((tend-tstart)^3)/4
trend.poly <- b1*((t-tstart)-(tend-tstart)/2) +
  b2*((t-tstart)^2 - ((tend-tstart)^2)/3) +
  b3*((t-tstart)^3 - ((tend-tstart)^3)/4)
periodic <- 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6)
y11 <- level.fixed + trend.fixed + noise
y12 <- level.fixed + trend.fixed + periodic + noise
y21 <- level.linear + trend.linear + noise
y22 <- level.linear + trend.linear + periodic + noise
y31 <- level.poly + trend.poly + noise
y32 <- level.poly + trend.poly + periodic + noise
signal <- data.frame(t=t, y11=y11, y12=y12,
                     y21=y21, y22=y22,
                     y31=y31, y32=y32)
p11 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.fixed) +
  geom_line(aes(y=y11), color="red") +
  labs(title="(level + trend)=0 + noise") +
  JT.theme
p12 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.fixed) +
  geom_line(aes(y=y12), color="red") +
  labs(title="(level + trend)=0 + periodic + noise") +
  JT.theme
p21 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.linear) +
  geom_line(aes(y=y21), color="red") +
  labs(title="(level + trend)=linear + noise") +
  JT.theme
p22 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.linear) +
  geom_line(aes(y=y22), color="red") +
  labs(title="(level + trend)=linear + periodic + noise") +
  JT.theme
p31 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.poly) +
  geom_line(aes(y=y31), color="red") +
  labs(title="(level + trend)=poly + noise") +
  JT.theme
p32 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.poly) +
  geom_line(aes(y=y32), color="red") +
  labs(title="(level + trend)=poly + periodic + noise") +
  JT.theme
grid.arrange(p11,p12,p21,p22,p31,p32,ncol=2)
@

\begin{figure}
\includegraphics[width=1\textwidth]{TS-JTvisual}
\caption{Categorize time series visually}
\label{fig:JTvisual}
\setfloatalignment{b}
\end{figure}

\newpage
\subsection{Deconstruction of an additive time series}
\label{subsec:deconstruct additive}

The ''construction" of a signal in an additive way in \ref{subsec:additive} gives us the procedure to deconstruct a given time series. We illustrate it using the times series from Figure~\ref{fig:JTvisual} that has all the components: (level + trend)=polynomial + peridicity + noise (bottom right). This variable is stored in a vector called ''y32".

\newthought{The first step}, finding the Level seems easy enough: just take the average of all data points.

<<>>=
Level <- mean(y32)
Level
@

\newthought{The second step} is tricky: should we now try to find the Trend or go for the Periodic component?

The Periodic component can add a lot of clutter to the data and influence the accuracy of the functions (lm, loess) that we use to find the Trend. However: looking for the existence of periodic elements with e.g. a Discrete Fourier Transform is hindered by the presence of a trend. For example: if we define a variable y as:
\begin{equation}
y = 2sin(2 \pi t/10) + 1sin(2 \pi t/25 + \pi/6) \quad t \in [0:99]
\end{equation}

<<echo=FALSE>>=
y <- 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6)
signal.test <- data.frame(t=t,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFT2sines,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines. t=[0:99]") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-FFT2sines}
\caption{}
\label{fig:FFT2sines}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

Because the time-step is equal to 1, the sampling period $T_{s}$ is also equal to 1 and the sampling frequency $F_{s}=\frac{1}{T_{s}}=1$. The smaller frequencies that the FFT can find lie in the interval $ [0,\frac{F_{s}}{2}]=[0,0.5]$ and the frequency resolution is $\frac{F_{s}}{N}=\frac{1}{100}= 0.01Hz$.

The results of the Fourier analysis are:
<<>>=
period.info$resultaat
@

<<label=reconsine1,fig=TRUE,include=FALSE, echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t + period.info$resultaat$fasehoek_pi[2]*pi)
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines. t=[0:99]") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-reconsine1}
\caption{}
\label{fig:reconsine1}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

So this is very clear: it discovers the two sinuses with the correct amplitude and frequency: 0.1 Hz (=1:10) and 0.04 Hz (=1:25). The phase angle seems wrong but this is because the FFT-transform works with the cosine: $sin(x)=cos(x - \pi/2)=cos(x-0.5\pi)$ and $sin(x+\pi/6)=cos(x-\pi/3)=cos(x-0.333\pi)$.

\newthought{When we change} the number of samples, it will change the frequency resolution. This means that the samples will not necessarily contain the zero-points of the sines, or their maximum value. However, FFT solves this by choosing an appropriate phase angle. For example: when we redo the analysis of the signal that is the result of the summation of two sine-functions but we change the number of samples (instead of t=[0..99], N=100 we use t=[0..100], N=101) we get the following results:

<<echo=FALSE>>=
t1 <- c(0:100)
y <- 2*sin(2*pi*t1/10) + sin(2*pi*t1/25 + pi/6)
signal.test <- data.frame(t=t1,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFT2sinesb,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines. t=[0:100]") +
  JT.theme
@

\begin{marginfigure}[-2cm]
\includegraphics[width=1\textwidth]{TS-FFT2sinesb}
\caption{}
\label{fig:FFT2sinesb}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The results of the Fourier analysis are:

<<>>=
period.info$resultaat
@

The frequencies and amplitude are very close to the correct value, but the phase angle is very different. When we compare the original function with the reconstructed function based on the FFT-analysis we get a good approximaton:

<<echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t1 + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t1 + period.info$resultaat$fasehoek_pi[2]*pi)
@

<<label=reconsine2,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines. t=[0:100]") +
  JT.theme
@

\begin{marginfigure}[-2cm]
\includegraphics[width=1\textwidth]{TS-reconsine2}
\caption{}
\label{fig:reconsine2}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newthought{Adding noise} to the signal does not disturb the Discrete Fourier Transform.
\begin{equation}
y = 2sin(2 \pi t/10) + 1sin(2 \pi t/25 + \pi/6) + rnorm(100,0,0.5) \quad t \in [0:99]
\end{equation}

<<echo=FALSE>>=
y <- 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6) + noise
signal.test <- data.frame(t=t,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFT2sinesnoise,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines + noise.") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-FFT2sinesnoise}
\caption{}
\label{fig:FFT2sinesnoise}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The results of the Fourier analysis are:
<<>>=
period.info$resultaat
@

<<label=reconsinenoise,fig=TRUE,include=FALSE, echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t + period.info$resultaat$fasehoek_pi[2]*pi)
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines + noise") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-reconsinenoise}
\caption{}
\label{fig:reconsinenoise}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The reconstructed signal is not perfect, but that is to be expected because the noise has been filtered out by the FFT.

\newpage
\newthought{The consequences of adding a trend} are however very disruptive to the behaviour of the FFT. For example, when we add a linear trend to the variable y it becomes:
\begin{equation}
y = 0.5t + 2sin(2 \pi t/10) + 1sin(2 \pi t/25 + \pi/6) \quad t \in [0:99]
\end{equation}

<<echo=FALSE>>=
y <- 0.5*t + 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6)
signal.test <- data.frame(t=t,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFTsines_lin,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines + linear trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-FFTsines_lin}
\caption{}
\label{fig:FFTsines_lin}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The results of the Fourier analysis are:

<<>>=
period.info$resultaat
@

The high value at 0Hz is the average value (the Level). But the sine-functions at 0.04Hz and 0.1Hz have vanished while the function generates spurious sines at 0.01Hz to 0.03Hz. The reconstructed signal is a long way from the original function (Figure~\ref{fig:reconsine3})

<<echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t + period.info$resultaat$fasehoek_pi[2]*pi)
@

<<label=reconsine3,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines with linear trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-reconsine3}
\caption{}
\label{fig:reconsine3}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newthought{Conclusion at this moment}: the Discrete Fourier Transform is a powerful method for finding the periodic component, \emph{provided the trend has been eliminated.}

\newpage
\section{Finding the trend}

\subsection{Linear models}

\newthought{To investigate different methods for finding the Trend} we will use as an example a data series constructed with a Level, a (polynomial) Trend, periodicity (sum of two sines) and noise. This is the series y32 at the bottom right of Figure~\ref{fig:JTvisual}. We first substract the Level from all values.

The \texttt{lm}-function does not work with date-type variables. It would not be a good idea to do so because it would try to put the intercept at date 0, which is probably the origin of the date stamp which is 01-01-1970 by default. But we can always use the index-variable, in this case the variable t.

\newthought{Let's start with a first degree linear model}:

<<>>=
Level <- mean(signal$y32)
signal$y32L <- signal$y32 - Level
lin.model <- lm(signal$y32L ~ signal$t)
summary(lin.model)
signal$lin.mod.y32 <- lin.model$fitted.values
@

<<label=JTlinmod,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal) + 
  geom_point(aes(x=t, y=y32L), size=1, color="red") +
  geom_linerange(aes(x=t, ymin=0,ymax=y32L),linetype=3, size=0.5) +
  geom_line(aes(x=t, y=lin.mod.y32), color="blue") +
  scale_y_continuous(breaks=seq(-10,10,1)) +
  labs(title="Trend of y32 without Level using a linear model") +
  JT.theme
@

\begin{marginfigure}[-2cm]
\includegraphics[width=1\textwidth]{TS-JTlinmod}
\caption{}
\label{fig:JTlinmod}
\setfloatalignment{b}
\end{marginfigure}

The nice thing about using this model is that we get a formula for the trend. However: from the summary of this model we learn that the $R^{2}$-value (\Sexpr{round(summary(lin.model)$r.squared,4)}) is not high. This linear model does not approximate the data very well.

\newthought{A polynomial model}
We don't know the degree of the polynomial that will be the best fit. Making this degree too hight risks getting an overfit. Let's start with a third degree polynomial:
<<>>=
poly3.model <- lm(signal$y32L ~ signal$t + I(signal$t^2) + I(signal$t^3))
summary(poly3.model)
signal$poly3.mod.y32 <- poly3.model$fitted.values
@

<<label=JTpoly3mod,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal) + 
  geom_point(aes(x=t, y=y32L), size=1, color="red") +
  geom_linerange(aes(x=t, ymin=0,ymax=y32L),linetype=3, size=0.5) +
  geom_line(aes(x=t, y=poly3.mod.y32), color="blue") +
  scale_y_continuous(breaks=seq(-10,10,1)) +
  labs(title="Trend of y32 without Level using a polynomial model") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-JTpoly3mod}
\caption{}
\label{fig:JTpoly3mod}
\setfloatalignment{b}
\end{marginfigure}

Much better: the $R^{2}$-value (\Sexpr{round(summary(poly3.model)$r.squared,4)}) is high. All coefficients have low p-values. We have to treat these with caution. We could try polynomials of lower (2) and higher (4) degree and see the evolution of the adjusted $R^{2}$-value.

<<echo=FALSE>>=
poly2.model <- lm(signal$y32L ~ signal$t + I(signal$t^2))
poly4.model <- lm(signal$y32L ~ signal$t + I(signal$t^2) + I(signal$t^3) + I(signal$t^4))
@

<<echo=FALSE>>=
AdjRsq <- data.frame(degree=c(2:4),
                     AdjustedRsquared=c(round(summary(poly2.model)$adj.r.squared,4),
                                        round(summary(poly3.model)$adj.r.squared,4),
                                        round(summary(poly4.model)$adj.r.squared,4)))
@

<<>>=
AdjRsq
@

The third-degree polynomial seems to avoid overfitting.

\newthought{Caution!} The polynomial seems to be a good fit to the data, but it is probably very dangerous to work with this polynomial \emph{outside} the interval in which it is defined. Extrapolating a polynomial, which we would do if we used the polynomial for forecasting, can lead to big errors.

\subsection{Trend as a series of numbers}

\newthought{\textsf{R} has a number of inbuilt functions} to find a trend. Best known are the \texttt{loess}- and \texttt{lowess}-functions. \sidenote[][-1cm]{There is an excellent YouTube video on the inner workings of the \texttt{loess}- and \texttt{lowess}-function: \url{https://www.youtube.com/watch?v=85XU1T9DIps}}

<<label=JTloessmod,fig=TRUE,include=FALSE, echo=FALSE>>=
loess.model <- loess(signal$y32L ~ signal$t, span=0.9, degree=1)
signal$loess.y32L <- predict(loess.model)
ggplot(data=signal) + 
  geom_point(aes(x=t, y=y32L), size=1, color="red") +
  geom_linerange(aes(x=t, ymin=0,ymax=y32L),linetype=3, size=0.5) +
  geom_line(aes(x=t, y=loess.y32L), color="blue") +
  scale_y_continuous(breaks=seq(-10,10,1)) +
  labs(title="Trend of y32 without Level with Loess-function (span=0.9, degree=1)") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-JTloessmod}
\caption{}
\label{fig:JTloessmod}
\setfloatalignment{b}
\end{marginfigure}

However, using the \texttt{loess}-function is not straigthforward because it implies setting parameters like \texttt{span}, \texttt{degree}, \texttt{family} etc. Different choices give different trend lines. There is some subjectiveness in this process. There is the alternative \texttt{lowess}-function. The following quote gives some background as to the differences between both functions: 
\medskip

''The main difference with respect to the first is that lowess allows only one predictor, whereas loess can be used to smooth multivariate data into a kind of surface. It also gives you confidence intervals. In these senses, loess is a generalization. Both use tricube weighting in the local regression." \sidenote{\url{https://stats.stackexchange.com/questions/161069/difference-between-loess-and-lowess}}.

\newthought{The successful method} for finding the Trend will be the one that simplifies the subsequent analysis of Periodicity and Noise. Let us look at the remaining signal when we substract from the original y32-signal the Level and the Trend. We look at two situations: one with the Trend as a polynomial of degree 3 (blue), and one with the Trend determined by the \texttt{loess}-function (red). The blue line (poly) seems to give the better result.

<<label=JTcompareTrend,fig=TRUE,include=FALSE, echo=FALSE>>=
signal$y32LTpoly <- signal$y32L - signal$poly3.mod.y32
signal$y32LTloess <- signal$y32L - signal$loess.y32L
ggplot(data=signal) +
  geom_line(aes(x=t, y=y32LTpoly), color="blue") +
  geom_line(aes(x=t, y=y32LTloess), color="red") +
  scale_y_continuous(breaks=seq(-10,10,1)) +
  labs(title="y32 without Level and Trend calculated with \n polynomial (blue) and Loess (red)") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-JTcompareTrend}
\caption{}
\label{fig:JTcompareTrend}
\setfloatalignment{b}
\end{marginfigure}

\newpage

\section{Finding periodicity}

\subsection{Using the Discrete Fourier Transform}

\newthought{At the moment} we have found the Level and the Trend, the latter in two ways. We can now find the periodicity using the Discrete Fourier Transform on the signal minus Level and Trend. 

<<label=y32LTpoly ,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t,y32LTpoly) -> signal.test
period.info <- JTR.FFT(signal.test)
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of y32 \n without Level and Trend (poly)") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-y32LTpoly}
\caption{}
\label{fig:y32LTpoly}
\setfloatalignment{b}
\end{marginfigure}

<<>>=
period.info$resultaat
@

<<label=y32LTloess ,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t,y32LTloess) -> signal.test
period.info <- JTR.FFT(signal.test)
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of y32 \n without Level and Trend (loess)") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-y32LTloess}
\caption{}
\label{fig:y32LTloess}
\setfloatalignment{b}
\end{marginfigure}

<<>>=
period.info$resultaat
@
\medskip
The DFT based on the Trend found with \texttt{loess} finds a new frequency peak at 0.01Hz (Figure~\ref{fig:y32LTloess}). This corresponds with a period T=100 which is the whole of the signal. There is a hint of the same in Figure~\ref{fig:y32LTpoly}.

\subsection{Finding the periodic signal when we know the frequency}

\newthought{Suppose that we know the frequency} of the periodic signal. Then there is an method to find the \emph{form} of this periodic signal. There is however a condition: the signal should be \emph{stationary}. This means that the variation of the periodic part does not change with time. An alternative formulation is: the amplitudes and phase angles of the different components of the Discrete Fourier Transform should remain the same in time. In the ideal case, without noise, the signal without Level and Trend should therefore be the same for every period.  If we plot the signal (without Level and Trend) for every period not sequentially but one on top of the other we should see only one signal. In reality this will not be the case because of the noise and because no signal absolutely conforms to the \emph{stationarity} condition. But here we have found two frequencies: 0.1Hz (period=10) and 0.04Hz (period=25). The period of the combined signal is equal to \emph{the smallest common multiple} period=50, because this is the smalles period with integer multiples of both periods.

<<label=periodpoly,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t,y32LTpoly) -> period.form
T.sig <- 50
period.form$period.nr <- rep(c(1:2) , each = T.sig)
period.form$period.nr <- as.factor(period.form$period.nr)
period.form$time <- rep(c(1:T.sig) , 2)
period.form %>% select(time, y32LTpoly) %>% group_by(time) %>% summarize(mean(y32LTpoly)) -> period.gem.poly
names(period.gem.poly) <- c("time","gem")
period.gem.poly$original <- 2*sin(2*pi*period.gem.poly$time/10) + sin(2*pi*period.gem.poly$time/25 + pi/6)
rms.error.poly <- sqrt(sum((period.gem.poly$original - period.gem.poly$gem)^2))
ggplot(data=period.form) + 
  geom_line(aes(x=time, y=y32LTpoly, color=period.form$period.nr)) +
  labs(title="Periodic signal for different periods (poly) \nand the average") +
  scale_colour_discrete(name = "period.nr") +
  geom_line(data=period.gem.poly, aes(x=time, y=gem), size=1.5, color="black") +
  geom_line(data=period.gem.poly, aes(x=time, y=original), linetype=1, size=1, color="green") +
  scale_y_continuous(breaks=seq(-5,5,1)) +
  JT.theme
@

\begin{marginfigure}[-9.5cm]
\includegraphics[width=1\textwidth]{TS-periodpoly}
\caption{}
\label{fig:periodpoly}
\setfloatalignment{b}
\end{marginfigure}

<<label=periodloess,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t,y32LTloess) -> period.form
period.form$period.nr <- rep(c(1:2) , each = T.sig)
period.form$period.nr <- as.factor(period.form$period.nr)
period.form$time <- rep(c(1:T.sig) , 2)
period.form %>% select(time, y32LTloess) %>% group_by(time) %>% summarize(mean(y32LTloess)) -> period.gem.loess
names(period.gem.loess) <- c("time","gem")
period.gem.loess$original <- 2*sin(2*pi*period.gem.loess$time/10) + sin(2*pi*period.gem.loess$time/25 + pi/6)
rms.error.loess <- sqrt(sum((period.gem.loess$original - period.gem.loess$gem)^2))
ggplot(data=period.form) + 
  geom_line(aes(x=time, y=y32LTloess, color=period.form$period.nr)) +
  labs(title="Periodic signal for different periods (loess) \nand average and original signal") +
  scale_colour_discrete(name = "period.nr") +
  geom_line(data=period.gem.loess, aes(x=time, y=gem), size=1.5, color="black") +
  geom_line(data=period.gem.loess, aes(x=time, y=original), linetype=1, size=1, color="green") +
  scale_y_continuous(breaks=seq(-5,5,1)) +
  JT.theme
@

\begin{marginfigure}[-2.5cm]
\includegraphics[width=1\textwidth]{TS-periodloess}
\caption{}
\label{fig:periodloess}
\setfloatalignment{b}
\end{marginfigure}

When we do this with the y32LTpoly and y32LTloess for the frequency of 0.02Hz (period=50) we get the plot in Figure~\ref{fig:periodpoly} and Figure~\ref{fig:periodloess}. Out of all the clutter we get a very reasonable approximation (black dots) of the original combination of two sine functions (green) with resp. period 10 and period 25! When we look at the RMS-value of the error (=difference between the calculated mean and the actual value of the periodic component without noise), then there is not much difference between the calculation based on the polynominal Trend or the one based on the \texttt{loess}-Trend.

<<>>=
rms.error.poly
rms.error.loess
@

\section{The deconstructed signal}
\newthought{We now have three components} of the signal y32: Level, Trend and Periodicity. The rest is Noise. A visualisation of this is given in Figure~\ref{fig:deconpoly} for the polynomial Trend and in Figure~\ref{fig:deconloess} for the \texttt{loess}-Trend.

<<label=deconpoly,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t, y32, poly3.mod.y32) -> decon.poly
decon.poly$LevelplusTrend <- mean(decon.poly$y32) + decon.poly$poly3.mod.y32
decon.poly$Periodic <- rep(period.gem.poly$gem[1:50],2)
decon.poly$Noise <- decon.poly$y32 - decon.poly$LevelplusTrend - decon.poly$Periodic
rms.noise.poly <- sqrt(sum(decon.poly$Noise^2))
decon.P <- data.frame(t = rep(decon.poly$t, 4) ,
                      value = c(decon.poly$y32, 
                                decon.poly$LevelplusTrend, 
                                decon.poly$Periodic, decon.poly$Noise),
                      type = factor(rep(c("original",
                                        "LevelplusTrend", 
                                        "Periodic",
                                        "Noise"), each=nrow(decon.poly)), 
                                  levels=c("original","LevelplusTrend", "Periodic","Noise")))
ggplot(data=decon.P, aes(x=t, y=value)) +
  geom_line() +
  facet_grid(type ~ ., scales = "free_y", switch = "y") +
  labs(title="Deconstructed y32 with polynomial Trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-deconpoly}
\caption{}
\label{fig:deconpoly}
\setfloatalignment{b}
\end{marginfigure}

<<label=deconloess,fig=TRUE,include=FALSE, echo=FALSE>>=
signal %>% select(t, y32, loess.y32L) -> decon.loess
decon.loess$LevelplusTrend <- mean(decon.loess$y32) + decon.loess$loess.y32L
decon.loess$Periodic <- rep(period.gem.loess$gem[1:50],2)
decon.loess$Noise <- decon.loess$y32 - decon.loess$LevelplusTrend - decon.loess$Periodic
rms.noise.loess <- sqrt(sum(decon.loess$Noise^2))
decon.L <- data.frame(t = rep(decon.loess$t, 4) ,
                      value = c(decon.loess$y32, 
                                decon.loess$LevelplusTrend, 
                                decon.loess$Periodic, decon.poly$Noise),
                      type = factor(rep(c("original",
                                        "LevelplusTrend", 
                                        "Periodic",
                                        "Noise"), each=nrow(decon.poly)), 
                                  levels=c("original","LevelplusTrend", "Periodic","Noise")))
ggplot(data=decon.L, aes(x=t, y=value)) +
  geom_line() +
  facet_grid(type ~ ., scales = "free_y", switch = "y") +
  labs(title="Deconstructed y32 with loess Trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-deconloess}
\caption{}
\label{fig:deconloess}
\setfloatalignment{b}
\end{marginfigure}

We can compare the quantity of Noise for both models. The noise in the signal was generated as a random draw from a normal distribution with $\mu=0$ and $\sigma=0.5$. Its RMS-value is:

<<echo=FALSE>>=
rms.noise <- sqrt(sum(noise^2))
@
<<>>=
rms.noise
@

The RMS-values of the Noise in the deconstructed signal are:
<<>>=
rms.noise.poly
rms.noise.loess
@

\end{document}