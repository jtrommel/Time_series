\documentclass{tufte-book}
\usepackage{graphicx}  % werken met figuren
\usepackage{gensymb} % werken met wetenschappelijke eenheden\usepackage{geometry}
\usepackage{changepage} % http://ctan.org/pkg/changepage
\usepackage[dutch,british]{babel} % instelling van de taal (woordsplitsing, spellingscontrole)
\usepackage[parfill]{parskip} % Paragrafen gescheiden door witte lijn en geen inspringing
\usepackage[font=small,skip=3pt]{caption} % Minder ruimte tussen figuur/table en ondertitel. Ondertitel klein
\usepackage{capt-of}
\usepackage{indentfirst}
\setlength{\parindent}{0.7cm}
\usepackage{enumitem} % Laat enumerate werken met letters
\usepackage{url}
\usepackage{lipsum}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
% Prints a trailing space in a smart way.
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{amsmath}

\DeclareGraphicsExtensions{.pdf,.png,.jpg}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
%   General parameters, for ALL pages:
    \renewcommand{\topfraction}{0.9}	% max fraction of floats at top
    \renewcommand{\bottomfraction}{0.9}	% max fraction of floats at bottom
%   Parameters for TEXT pages (not float pages):
    \setcounter{topnumber}{2}
    \setcounter{bottomnumber}{2}
    \setcounter{totalnumber}{4}     % 2 may work better
    \renewcommand{\textfraction}{0.1}	% allow minimal text w. figs
%   Parameters for FLOAT pages (not text pages):
    \renewcommand{\floatpagefraction}{0.8}	% require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\setcounter{secnumdepth}{3}

\newcommand{\tthdump}[1]{#1}

\newcommand{\openepigraph}[2]{
  \begin{fullwidth}
  \sffamily\large
    \begin{doublespace}
      \noindent\allcaps{#1}\\ % epigraph
      \noindent\allcaps{#2} % author
    \end{doublespace}
  \end{fullwidth}
}


\usepackage{makeidx}
\makeindex

\title{Time series}
\author{Jan Trommelmans}

\begin{document}
\SweaveOpts{concordance=TRUE,prefix.string=TS}
\setkeys{Gin}{width=1.1\marginparwidth} %% Sweave

\frontmatter

\newpage\thispagestyle{empty}
\openepigraph{
It's tough to make predictions, especially about the future.
}{Yogi Berra
}

\maketitle

\chapter*{Introduction}
\label{ch:introduction}

In the ''Good Judgement Open" forecast tournament, many questions deal with time series: data obtained at regularly spaced time intervals. Examples are: daily closing price of Brent Crude Oil, polling results for different political parties prior to an election, the exchange rate of one currency vs. another. These time series can exhibit a number of properties:
\begin{enumerate}
  \item a \emph{trend}. This can take the form of a function (linear, polynomial, exponential ...) that we obtain from a model. Or it can be found in the form of calculated values using a smoothing operation.
  \item a \emph{periodic} element. Again this can be modelled by a function (e.g. the sum of sine-funtion using the Discrete Fourier Transform of the (detrended) signal). Or it can take the form of calculated values such as Additive/Multiplicative Seasonal Effects.
  \item an element of \emph{error}. This can be caused by unknown factors, unforeseen periodic influences, measuring and/or rounding errors etc.
\end{enumerate}

The programming language \textsf{R} has a specific object to work with time series. It is aptly named \emph{time series object}. This object does not only include the data that were recorded, but also information about the time it was recorded. \textsf{R} base has the \texttt{ts}-command which turns a vector or matrix of data into a time series object. When we want to transform our data into a time series object with \texttt{ts}, we have to include a parameter which is called \texttt{frequency}. This causes a lot of problems (for me a least).

The aim of this article is to get some clarity about how to set this parameter \texttt{frequency} and its consequences when using \textsf{R} base languange or one of the many packages that were specifically developed for working with time series objects.

\mainmatter

\chapter{Working with time series in a standard data frame}
\label{ch:data frame}

\section{Making your own date column}
\label{sec:own date column}

\newthought{Time series data} are usually available as a vector or a matrix of numerical values. An example

<<echo=FALSE>>=
library(tidyverse)
library(xtable)
library(lubridate)
library(gridExtra)
@

% Setting the ggplot theme:
<<echo=FALSE>>=
JT.theme <- theme(panel.border = element_rect(fill = NA, colour = "gray10"),
                  panel.background = element_blank(),
                  panel.grid.major = element_line(colour = "gray85"),
                  panel.grid.minor = element_line(colour = "gray85"),
                  panel.grid.major.x = element_line(colour = "gray85"),
                  axis.text = element_text(size = 8 , face = "bold"),
                  axis.title = element_text(size = 9 , face = "bold"),
                  plot.title = element_text(size = 10 , face = "bold"),
                  strip.text = element_text(size = 8 , face = "bold"),
                  strip.background = element_rect(colour = "black"),
                  legend.text = element_text(size = 8),
                  legend.title = element_text(size = 9 , face = "bold"),
                  legend.background = element_rect(fill = "white"),
                  legend.key = element_rect(fill = "white"))
@

% Defining my functions
<<echo=FALSE>>=
JTR.FFT <- function(signal.df) {
  # This function calculates the FFT for a time series stored in a data frame with as first column the time (or order of measurement) and as second column the vector of measurements.
  # The result is a list. 
  # The first element of the list is freqspec: the N frequencies plus for each frequency the amplitude and phase.
  # The second element of the list is resultaat: a data frame with those frequencies for which the amplitude  are at least 33% of the maximum amplitude. The data frame is sorted from highes amplitude to lowest. This data fram can be seen as containing the most influencial frequencies.
  signal <- signal.df
  names(signal) <- c("t","x")
  N <- nrow(signal)
  Ts <- as.numeric(signal$t[2]-signal$t[1])
  Fs <- 1/Ts
  # Calculation of the double sided en single sided spectrum
  z <- fft(signal$x)
  P2 <- Mod(z/N)
  P1 <- P2[1:((N/2)+1)]
  P1[2:(length(P1)-1)] <- 2*P1[2:(length(P1)-1)]
  freq <- seq(0, (Fs/2)-(Fs/N), Fs/N)
  freqspec <- data.frame(freq=freq,amp=P1[1:(N/2)],arg=Arg(z[1:(N/2)]))
  # Finding the most important elements in the frequency spectrum
  grens <- ifelse(freqspec$freq[freqspec$amp==max(freqspec$amp)]==0,max(freqspec$amp[2:nrow(freqspec)])/3,max(freqspec$amp)/3)
  aantal <- length(freqspec$amp[freqspec$amp>grens])
  resultaat <- data.frame(freq=rep(0,aantal), amp=rep(0,aantal), fasehoek=rep(0,aantal))
  resultaat <- data.frame(freq=freqspec$freq[freqspec$amp>grens],
                          amp=freqspec$amp[freqspec$amp>grens],
                          fasehoek_pi=freqspec$arg[freqspec$amp>grens]/pi)
  resultaat <- resultaat[order(-resultaat$amp),]
  return(list("freqspec"=freqspec,"resultaat"=resultaat))
}
@

<<echo=FALSE>>=
JT.example1 <- c(6, 5.5, 4.2, 2.8, 3.7, 7.1, 6.8, 4.4, 6.7, 7.9)
JT.example1.df <- data.frame(value=JT.example1) 
print(JT.example1.df)
@

When these data are collected sequentially, the rownames give the order. We put this order into a new variable ''nr".

<<label=JTex1,fig=TRUE,include=FALSE, echo=FALSE>>=
JT.example1.df <- data.frame(nr=c(1:length(JT.example1)), value=JT.example1)
ggplot(data=JT.example1.df) +
  geom_point(aes(x=nr,y=value), size=3, color="red") +
  geom_linerange(aes(x=nr,ymin=0,ymax=value),linetype=3, size=1) +
  scale_x_continuous(breaks=c(1:length(JT.example1))) +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Example of equally spaced observations") +
  JT.theme
@

\begin{marginfigure}[-7cm]
\includegraphics[width=1\textwidth]{TS-JTex1}
\label{fig:JTex1}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newthought{Of course} it could be interesting to have the actual time (date + hms) at which the observations were made. The \texttt{lubridate}-package gives us simple to use and easy to understand function that we can use to create \texttt{date}-objects in R. For example: if the measurements were made on October 8th 2015, starting at 13:45 and done every minute we can create a column ''date" using \texttt{lubridate} and \texttt{seq}-function. Take care to set the ''by"-parameter with as.difftime().

<<>>=
Sys.setenv(TZ="Europe/Brussels")
JT.example1.df$date <- seq(ymd_hms("2015-10-08 13:45:00"), 
                           length = 10, by=as.difftime(minutes(1)))
str(JT.example1.df)
@

We can see that the ''date"-variable has the class \texttt{date}.

<<echo=FALSE>>=
print(JT.example1.df)
@

ggplot can handle date-type variables. This has the advantage that the time-axis is now using the correct times at which the measurements were made.

<<label=JTex2,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=JT.example1.df) +
  geom_point(aes(x=date, y=value), size=3, color="red") +
  geom_linerange(aes(x=date, ymin=0,ymax=value),linetype=3, size=1) +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Example of equally spaced observations with exact times") +
  JT.theme
@

\begin{marginfigure}[-7cm]
\includegraphics[width=1\textwidth]{TS-JTex2}
\label{fig:JTex2}
\setfloatalignment{b}
\end{marginfigure}

Other sequences can be generated in the same way:

<<>>=
other.seq <- seq(from=ymd("2017-01-01"), 
                 to=ymd("2017-01-31"), 
                 by=as.difftime(days(2)))
other.seq
@

\newpage
\section{Looking at the data}
\label{sec:visualize}

\newthought{Visualisation} of the data is a good first step because it gives an indication of the basic components of a time series and the way they are linked. This ''linking" is usually described as \emph{additive} or \emph{multiplicative}. I will start with the \emph{additive} linking because I have some problems with the \emph{multiplicative}.

\begin{enumerate}
  \item: the \emph{Level} of the signal: this is the average value of the series.
  \item: the \emph{Trend} of the signal: the change in the series from one period to the other
  \item: the \emph{Periodicity} or \emph{Seasonality} of the signal: short term cyclical behaviour that can be observed several times in the series
  \item: the \emph{Noise} in the signal: random variation caused by measurement error or the influence of unknown factors
\end{enumerate}

\subsection{Additive components of a time series}
\label{subsec:additive}
The \emph{additive} linkage between these components is simple: the complete signal is the sum of all these terms:
\begin{equation}
y[t_{i}] = Level + Trend[t_{i}] + Periodicity[t_{i}] + Noise[t_{i}]
\end{equation}

This seems simple but there is an unusual use of the term \emph{Trend}. For a simple linear dependency of y on t (starting at $t_{start}$ and ending at $t_{end}$), for me the ''trend" is given by:
\begin{equation}
y(t)=b_{0}+b_{1} \left( t-t_{start}  \right)
\end{equation}

However: the \emph{Level} of the time seris is defined as its average and thus as a constant. Assuming that the averages of the periodic part and of the noise are zero, what remains is the average of the linear part $ y(t)=b_{0}+b_{1} \left( t-t_{start}  \right)$:
\begin{equation}
Level=\bar{y}=b_{0} + b_{1} \frac{\left( t_{end}-t_{start} \right)}{2} 
\end{equation}

This means that what is meant by \emph{Trend} is equal to:
\begin{equation}
Trend=y(t)-Level=b_{1}\left[ t-\frac{t_{start}+t_{end}}{2} \right]
\end{equation}

We can generalize this argument for a polynomial function (degree>2) of y. For example: a third degree polynomial for the ''trend":
\begin{equation}
y(t)=b_{0} + b_{1} \left( t-t_{start}  \right) + b_{2} \left( t-t_{start}  \right)^{2} + b_{3} \left( t-t_{start}  \right)^{3}
\end{equation}

The \emph{Level} is its mean value:
\begin{equation}
Level=\bar{y}=\frac{1}{t_{end}-t_{start}} \int\limits_{t_{start}}^{t_{end}} ydt=b_{0}+b_{1}\frac{t_{end}-t_{start}}{2} + b_{2}\frac{(t_{end}-t_{start})^{2}}{3} +  b_{3}\frac{(t_{end}-t_{start})^{3}}{4}
\end{equation}

and the \emph{Trend} is then:
\begin{equation}
Trend=y(t)-Level=b_{1}\left[ (t - t_{start}) - \frac{t_{end} - t_{start}}{2} \right] + b_{2}\left[ (t - t_{start})^{2} - \frac{(t_{end} - t_{start})^2}{3} \right] + b_{3}\left[ (t - t_{start})^{3} - \frac{(t_{end}-t_{start})^3}{4} \right]
\end{equation}

The base signal is white noise: no level, no trend, no periodicity, just noise. Then we can superpose on this a level and/or a trend and/or periodicity. We start with only \texttt{additive} superposition. The possible resulting signals are summarized in Figure~\ref{fig:JTvisual}.

<<label=JTvisual,fig=TRUE,include=FALSE, echo=FALSE>>=
set.seed(123)
t <- c(0:99)
tstart <- min(t)
tend <- max(t)
noise <- rnorm(100,0,0.5)
# coefficients of the trend
b0 <- 1
b1 <- 0.05
b2 <- 0.005
b3 <- -0.00005
level.fixed <- 0
trend.fixed <- 0
level.linear <- b0 + b1*(tend - tstart)/2
trend.linear <- b1*(t - (tstart + tend)/2)
level.poly <- b0 + b1*(tend-tstart)/2 +
  b2*((tend-tstart)^2)/3 +
  b3*((tend-tstart)^3)/4
trend.poly <- b1*((t-tstart)-(tend-tstart)/2) +
  b2*((t-tstart)^2 - ((tend-tstart)^2)/3) +
  b3*((t-tstart)^3 - ((tend-tstart)^3)/4)
periodic <- 2*sin(2*pi*t/20 + pi/3) + 0.2*sin(2*pi*t/60 - pi/4)
y11 <- level.fixed + trend.fixed + noise
y12 <- level.fixed + trend.fixed + periodic + noise
y21 <- level.linear + trend.linear + noise
y22 <- level.linear + trend.linear + periodic + noise
y31 <- level.poly + trend.poly + noise
y32 <- level.poly + trend.poly + periodic + noise
signal <- data.frame(t=t, y11=y11, y12=y12,
                     y21=y21, y22=y22,
                     y31=y31, y32=y32)
p11 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.fixed) +
  geom_line(aes(y=y11), color="red") +
  labs(title="(level + trend)=0 + noise") +
  JT.theme
p12 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.fixed) +
  geom_line(aes(y=y12), color="red") +
  labs(title="(level + trend)=0 + periodic + noise") +
  JT.theme
p21 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.linear) +
  geom_line(aes(y=y21), color="red") +
  labs(title="(level + trend)=linear + noise") +
  JT.theme
p22 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.linear) +
  geom_line(aes(y=y22), color="red") +
  labs(title="(level + trend)=linear + periodic + noise") +
  JT.theme
p31 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.poly) +
  geom_line(aes(y=y31), color="red") +
  labs(title="(level + trend)=poly + noise") +
  JT.theme
p32 <- ggplot(data=signal, aes(x=t)) +
  geom_hline(yintercept=level.poly) +
  geom_line(aes(y=y32), color="red") +
  labs(title="(level + trend)=poly + periodic + noise") +
  JT.theme
grid.arrange(p11,p12,p21,p22,p31,p32,ncol=2)
@

\begin{figure}
\includegraphics[width=1\textwidth]{TS-JTvisual}
\caption{Categorize time series visually}
\label{fig:JTvisual}
\setfloatalignment{b}
\end{figure}

\newpage
\subsection{Deconstruction of an additive time series}
\label{subsec:deconstruct additive}

The ''construction" of a signal in an additive way in \ref{subsec:additive} gives us the procedure to deconstruct a given time series. We illustrate it using the times series from Figure~\ref{fig:JTvisual} that has all the components: (level + trend)=polynomial + peridicity + noise (bottom right). This variable is stored in a vector called ''y32".

\newthought{The first step}, finding the Level seems easy enough: just take the average of all data points.

<<>>=
Level <- mean(y32)
Level
@

\newthought{The second step} is tricky: should we now try to find the Trend or go for the Periodic component?

The Periodic component can add a lot of clutter to the data and influence the accuracy of the functions (lm, loess) that we use to find the Trend. However: looking for the existence of periodic elements with e.g. a Discrete Fourier Transform is hindered by the presence of a trend. For example: if we define a variable y as:
\begin{equation}
y = 2sin(2 \pi t/10) + 1sin(2 \pi t/25 + \pi/6) \quad t \in [0:99]
\end{equation}

<<echo=FALSE>>=
y <- 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6)
signal.test <- data.frame(t=t,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFT2sines,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines. t=[0:99]") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-FFT2sines}
\label{fig:FFT2sines}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

Because the time-step is equal to 1, the sampling period $T_{s}$ is also equal to 1 and the sampling frequency $F_{s}=\frac{1}{T_{s}}=1$. The smaller frequencies that the FFT can find lie in the interval $ [0,\frac{F_{s}}{2}]=[0,0.5]$ and the frequency resolution is $\frac{F_{s}}{N}=\frac{1}{100}= 0.01Hz$.

The results of the Fourier analysis are:
<<>>=
period.info$resultaat
@

<<label=reconsine1,fig=TRUE,include=FALSE, echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t + period.info$resultaat$fasehoek_pi[2]*pi)
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines. t=[0:99]") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-reconsine1}
\label{fig:reconsine1}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

So this is very clear: it discovers the two sinuses with the correct amplitude and frequency: 0.1 Hz (=1:10) and 0.04 Hz (=1:25). The phase angle seems wrong but this is because the FFT-transform works with the cosine: $sin(x)=cos(x - \pi/2)=cos(x-0.5\pi)$ and $sin(x+\pi/6)=cos(x-\pi/3)=cos(x-0.333\pi)$.

\newthought{When we change} the number of samples, it will change the frequency resolution. This means that the samples will not necessarily contain the zero-points of the sines, or their maximum value. However, FFT solves this by choosing an appropriate phase angle. For example: when we redo the analysis of the signal that is the result of the summation of two sine-functions but we change the number of samples (instead of t=[0..99], N=100 we use t=[0..100], N=101) we get the following results:

<<echo=FALSE>>=
t1 <- c(0:100)
y <- 2*sin(2*pi*t1/10) + sin(2*pi*t1/25 + pi/6)
signal.test <- data.frame(t=t1,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFT2sinesb,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines. t=[0:100]") +
  JT.theme
@

\begin{marginfigure}[-2cm]
\includegraphics[width=1\textwidth]{TS-FFT2sinesb}
\label{fig:FFT2sinesb}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The results of the Fourier analysis are:

<<>>=
period.info$resultaat
@

The frequencies and amplitude are very close to the correct value, but the phase angle is very different. When we compare the original function with the reconstructed function based on the FFT-analysis we get a good approximaton:

<<echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t1 + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t1 + period.info$resultaat$fasehoek_pi[2]*pi)
@

<<label=reconsine2,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines. t=[0:100]") +
  JT.theme
@

\begin{marginfigure}[-2cm]
\includegraphics[width=1\textwidth]{TS-reconsine2}
\label{fig:reconsine2}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newthought{The consequences of adding a trend} are however very disruptive to the behaviour of the FFT. For example, when we add a linear trend to the variable y it becomes:
\begin{equation}
y = 0.5t + 2sin(2 \pi t/10) + 1sin(2 \pi t/25 + \pi/6) \quad t \in [0:99]
\end{equation}

<<echo=FALSE>>=
y <- 0.5*t + 2*sin(2*pi*t/10) + sin(2*pi*t/25 + pi/6)
signal.test <- data.frame(t=t,y=y)
period.info <- JTR.FFT(signal.test)
@

<<label=FFTsines_lin,fig=TRUE,include=FALSE, echo=FALSE>>=
freqspec <- period.info$freqspec
ggplot(data=freqspec) + 
  geom_line(aes(x=freq,y=amp)) +
  labs(title="Frequency spectrum of two sines + linear trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-FFTsines_lin}
\label{fig:FFTsines_lin}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

The results of the Fourier analysis are:

<<>>=
period.info$resultaat
@

The high value at 0Hz is the average value (the Level). But the sine-functions at 0.04Hz and 0.1Hz have vanished while the function generates spurious sines at 0.01Hz to 0.03Hz. The reconstructed signal is a long way of the original function (Figure~\ref{fig:reconsine3})

<<echo=FALSE>>=
signal.test$FFT <- period.info$resultaat$amp[1]*cos(2*pi*period.info$resultaat$freq[1]*t + period.info$resultaat$fasehoek_pi[1]*pi) + period.info$resultaat$amp[2]*cos(2*pi*period.info$resultaat$freq[2]*t + period.info$resultaat$fasehoek_pi[2]*pi)
@

<<label=reconsine3,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=signal.test, aes(x=t)) + 
  geom_line(aes(y=y)) +
  geom_line(aes(y=FFT), color="red") +
  labs(title="Reconstruction of two sines with linear trend") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-reconsine3}
\label{fig:reconsine3}
\setfloatalignment{b}% forces caption to be bottom-aligned
\end{marginfigure}

\newpage
\section{Finding a trend}

\subsection{Trend in a formula}

The \texttt{lm}-function does not work with a date. It would not be a good idea to do so because it would try to put the intercept at date 0, which is probably the origin ot the date stamp which is 01-01-1970 by default. But we can always use the ''nr"-variable:

<<>>=
lin.model <- lm(JT.example1.df$value ~ JT.example1.df$nr)
summary(lin.model)
JT.example1.df$lin.mod <- lin.model$fitted.values
@

<<label=JTlinmod,fig=TRUE,include=FALSE, echo=FALSE>>=
ggplot(data=JT.example1.df) + 
  geom_point(aes(x=date, y=value), size=3, color="red") +
  geom_linerange(aes(x=date, ymin=0,ymax=value),linetype=3, size=1) +
  geom_line(aes(x=date, y=lin.mod), color="blue") +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Trend by linear model") +
  JT.theme
@

\begin{marginfigure}[-7cm]
\includegraphics[width=1\textwidth]{TS-JTlinmod}
\label{fig:JTlinmod}
\setfloatalignment{b}
\end{marginfigure}

The nice thing about using this model is that we get a formula for the trend. 

\newpage
\subsection{Trend as a series of numbers}

\textsf{R} has a number of inbuilt function to find a trend. Best known are the \texttt{loess}- and \texttt{lowess}-functions. \sidenote[][-1cm]{There is an excellent YouTube video on the inner workings of the \texttt{loess}- and \texttt{lowess}-function: \url{https://www.youtube.com/watch?v=85XU1T9DIps}}

<<label=JTloessmod,fig=TRUE,include=FALSE, echo=FALSE>>=
loess.model <- loess(JT.example1.df$value ~ JT.example1.df$nr, span=0.9, degree=1)
JT.example1.df$loess.mod <- predict(loess.model)
ggplot(data=JT.example1.df) + 
  geom_point(aes(x=date, y=value), size=3, color="red") +
  geom_linerange(aes(x=date, ymin=0,ymax=value),linetype=3, size=1) +
  geom_line(aes(x=date, y=loess.mod), color="blue") +
  scale_y_continuous(breaks=seq(0,10,1)) +
  labs(title="Trend by Loess-function (span=0.9, degree=1)") +
  JT.theme
@

\begin{marginfigure}[0cm]
\includegraphics[width=1\textwidth]{TS-JTloessmod}
\label{fig:JTloessmod}
\setfloatalignment{b}
\end{marginfigure}

However, using the \texttt{loess}-function is not straigthforward because it implies setting parameters like \texttt{span}, \texttt{degree}, \texttt{family} etc. Different choices give different trend lines. There is some subjectiveness in this process. There is the alternative \texttt{lowess}-function. The following quote gives some background as to the differences between both functions: \quote{The main difference with respect to the first is that lowess allows only one predictor, whereas loess can be used to smooth multivariate data into a kind of surface. It also gives you confidence intervals. In these senses, loess is a generalization. Both use tricube weighting in the local regression.} \sidenote{\url{https://stats.stackexchange.com/questions/161069/difference-between-loess-and-lowess}}.

\section{Finding periodicity}

\newthought{We can decompose} the signal by finding the level


\end{document}